<%
    const structName = _.upperFirst(_.camelCase(table.pname));
    const getType = (column) => {
        let result = '';
        if (column.type === 'UUID') {
            result = 'Uuid';
        } else if (column.type === 'BIGINT') {
            result = 'i64';
        } else if (column.type === 'TIMESTAMPTZ') {
            result = 'DateTime<Utc>';
        } else if (column.type === 'TIMESTAMPTZ[]') {
            result = 'Vec<DateTime<Utc>>';
        } else if (column.type === 'NUMERIC') {
            result = 'rust_decimal::Decimal';
        } else if (column.type === 'NUMERIC[]') {
            result = 'Vec<rust_decimal::Decimal>';
        } else if (column.type === 'JSONB') {
            result = 'serde_json::Value';
        } else if (column.type === 'TEXT[]') {
            result = 'Vec<String>';
        } else if (column.type === 'UUID[]') {
            result = 'Vec<Uuid>';
        } else if (column.domain === '区分') {
            result = `crate::kbn_constants::${_.upperFirst(_.camelCase(column.pname))}`;
        } else {
            result = 'String';
        }
        return result;
    };
    const getRefer = (column) => {
        let result = '';
        if (column.type === 'UUID') {
            result = '';
        } else if (column.type === 'BIGINT') {
            result = '';
        } else if (column.type === 'TIMESTAMPTZ') {
            result = '';
        } else if (column.type === 'TIMESTAMPTZ[]') {
            result = '&';
        } else if (column.type === 'NUMERIC') {
            result = '';
        } else if (column.type === 'NUMERIC[]') {
            result = '&';
        } else if (column.type === 'JSONB') {
            result = '&';
        } else if (column.type === 'TEXT[]') {
            result = '&';
        } else if (column.type === 'UUID[]') {
            result = '&';
        } else {
            result = '&';
        }
        return result;
    };
    const columns = table.columns.map((column) => {
        let typeValue = getType(column);
        if (!column.notNull) {
            typeValue = `Option<${typeValue}>`;
        }
        return  `pub ${column.pname}: ${typeValue}`;
    }).join(',\n    ');
    const insertColumns = table.columns.map((column) => {
        return  `${column.pname}`;
    }).join('\n        ,');
    const insertValues = table.columns.map((column, index) => {
        return  `$${index + 1}`;
    }).join('\n        ,');
    const insertBinds = table.columns.map((column, index) => {
        return  `.bind(${getRefer(column)}self.${column.pname})`;
    }).join('\n            ');
    const updates = table.columns.filter(column => column.pname !== 'uuid').map((column, index) => {
        let col_text = `${column.pname} = $${index + 2}`;
        return col_text;
      }).join('\n    ,');
    const selects = table.columns.map((column) => {
        return  `${column.pname}`;
    }).join('\n        ,');

    const fields = table.columns.map((column) => {
        return  `pub ${column.pname}: &'static str,`;
    }).join('\n    ');
    const field_instances = table.columns.map((column) => {
        return  `${column.pname}: "${column.pname}",`;
    }).join('\n        ');
%>use crate::Pool;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use derive_builder::Builder;
use sqlx::prelude::*;
use sql_query_builder as sqb;

pub struct <%= structName %>Fields {
    <%- fields %>
    pub created_at: &'static str,
    pub created_pg: &'static str,
    pub created_uuid: &'static str,
    pub deleted_at: &'static str,
    pub deleted_pg: &'static str,
    pub deleted_uuid: &'static str,
    pub updated_at: &'static str,
    pub updated_pg: &'static str,
    pub updated_uuid: &'static str,
    pub bk: &'static str,
}

#[derive(Serialize, Deserialize, Debug, Clone, Builder, Default, FromRow)]
#[builder(setter(into), default, field(public))]
pub struct <%= structName %> {
    <%- columns %>,
    pub created_uuid: Uuid,
    pub updated_uuid: Uuid,
    pub deleted_uuid: Uuid,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub deleted_at: Option<DateTime<Utc>>,
    pub created_pg: String,
    pub updated_pg: String,
    pub deleted_pg: String,
    pub bk: Option<String>,
}

impl <%= structName %> {
    pub const TABLE_NAME: &'static str = "public.<%= table.pname %>";
    
    pub const FIELDS: <%= structName %>Fields = <%= structName %>Fields {
        <%- field_instances %>
        created_at: "created_at",
        created_pg: "created_pg",
        created_uuid: "created_uuid",
        deleted_at: "deleted_at",
        deleted_pg: "deleted_pg",
        deleted_uuid: "deleted_uuid",
        updated_at: "updated_at",
        updated_pg: "updated_pg",
        updated_uuid: "updated_uuid",
        bk: "bk",
    };

    pub const SELECT_SQL: &str = r#"
    SELECT
        <%- selects %>
        ,created_uuid
        ,updated_uuid
        ,deleted_uuid
        ,created_at
        ,updated_at
        ,deleted_at
        ,created_pg
        ,updated_pg
        ,deleted_pg
        ,bk
    FROM
        public.<%= table.pname %>
    "#;

    pub const INSERT_SQL: &str = r#"
    INSERT INTO public.<%= table.pname %> (
        <%- insertColumns %>
        ,created_uuid
        ,updated_uuid
        ,deleted_uuid
        ,created_at
        ,updated_at
        ,deleted_at
        ,created_pg
        ,updated_pg
        ,deleted_pg
        ,bk
    ) VALUES (
        <%- insertValues %>
        ,$<%- table.columns.length + 1 %>
        ,$<%- table.columns.length + 2 %>
        ,$<%- table.columns.length + 3 %>
        ,$<%- table.columns.length + 4 %>
        ,$<%- table.columns.length + 5 %>
        ,$<%- table.columns.length + 6 %>
        ,$<%- table.columns.length + 7 %>
        ,$<%- table.columns.length + 8 %>
        ,$<%- table.columns.length + 9 %>
        ,$<%- table.columns.length + 10 %>
    ) RETURNING
        <%- insertColumns %>
        ,created_uuid
        ,updated_uuid
        ,deleted_uuid
        ,created_at
        ,updated_at
        ,deleted_at
        ,created_pg
        ,updated_pg
        ,deleted_pg
        ,bk
    "#;

    pub const UPDATE_SQL: &str = r#"
    UPDATE public.<%= table.pname %> SET
        <%- updates %>
        ,created_uuid = $<%- table.columns.length + 1 %>
        ,updated_uuid = $<%- table.columns.length + 2 %>
        ,deletded_uuid = $<%- table.columns.length + 3 %>
        ,created_at = $<%- table.columns.length + 4 %>
        ,updated_at = $<%- table.columns.length + 5 %>
        ,deleted_at = $<%- table.columns.length + 6 %>
        ,created_pg = $<%- table.columns.length + 7 %>
        ,updated_pg = $<%- table.columns.length + 8 %>
        ,deleted_pg = $<%- table.columns.length + 9 %>
        ,bk = $<%- table.columns.length + 10 %>
    WHERE
        uuid = $1
    RETURNING
        <%- insertColumns %>
        ,created_uuid
        ,updated_uuid
        ,deleted_uuid
        ,created_at
        ,updated_at
        ,deleted_at
        ,created_pg
        ,updated_pg
        ,deleted_pg
        ,bk
    "#;

    pub const DELETE_SQL: &str = r#"
    DELETE FROM public.<%= table.pname %>
    WHERE
        uuid = $1
    RETURNING
        <%- insertColumns %>
        ,created_uuid
        ,updated_uuid
        ,deleted_uuid
        ,created_at
        ,updated_at
        ,deleted_at
        ,created_pg
        ,updated_pg
        ,deleted_pg
        ,bk
    "#;

    pub const DELETE_ALL_SQL: &str = r#"
    DELETE FROM public.<%= table.pname %>
    "#;

    pub async fn insert(&self, pool: &Pool) -> Result<Self, sqlx::Error> {
        sqlx::query_as(Self::INSERT_SQL)
            <%- insertBinds %>
            .bind(self.created_uuid)
            .bind(self.updated_uuid)
            .bind(self.deleted_uuid)
            .bind(self.created_at)
            .bind(self.updated_at)
            .bind(self.deleted_at)
            .bind(&self.created_pg)
            .bind(&self.updated_pg)
            .bind(&self.deleted_pg)
            .bind(&self.bk)
            .fetch_one(pool)
            .await
    }

    pub async fn update(&self, pool: &Pool) -> Result<Self, sqlx::Error> {
        sqlx::query_as(Self::UPDATE_SQL)
            <%- insertBinds %>
            .bind(self.created_uuid)
            .bind(self.updated_uuid)
            .bind(self.deleted_uuid)
            .bind(self.created_at)
            .bind(self.updated_at)
            .bind(self.deleted_at)
            .bind(&self.created_pg)
            .bind(&self.updated_pg)
            .bind(&self.deleted_pg)
            .bind(&self.bk)
            .fetch_one(pool)
            .await
    }

    pub async fn delete(&self, pool: &Pool) -> Result<Self, sqlx::Error> {
        Self::delete_one(pool, &self.uuid).await
    }

    pub async fn delete_one(pool: &Pool, uuid: &Uuid) -> Result<Self, sqlx::Error> {
        sqlx::query_as(Self::DELETE_SQL)
            .bind(uuid)
            .fetch_one(pool)
            .await
    }

    pub async fn delete_all(pool: &Pool) -> Result<(), sqlx::Error> {
        let _ = sqlx::query(Self::DELETE_ALL_SQL)
            .execute(pool)
            .await?;
        Ok(())
    }

    pub async fn select_all(pool: &Pool) -> Result<Vec<Self>, sqlx::Error> {
        let rows: Vec<Self> = sqlx::query_as(Self::SELECT_SQL)
            .fetch_all(pool)
            .await?;
        Ok(rows)
    }

    pub async fn select_one(pool: &Pool, uuid: &Uuid) -> Result<Option<Self>, sqlx::Error> {
        let query = sqb::Select::new()
            .raw(Self::SELECT_SQL)
            .where_clause(&format!("{} = $1", Self::FIELDS.uuid));
        let one: Option<Self> = sqlx::query_as(&query.as_string())
            .bind(uuid)
            .fetch_optional(pool)
            .await?;
        Ok(one)
    }
}
